import sys

sys.path.append('./tools/')
from pathtree import PathTree
from ortools.constraint_solver import pywrapcp
from matplotlib.cbook import flatten
from functools import wraps
import numpy as np
from sortedcontainers import SortedDict
from sympy import S, sympify, Add
from itertools import combinations

def find_bcliques(graph):
    """
    Identify B-cliques in the graph.
    A B-clique is a pair of node subsets (V1, V2) such that all nodes in V1 have edges to all nodes in V2.
    :param graph: Input graph (dictionary representation).
    :return: List of B-cliques [(V1, V2)].
    """
    bcliques = []
    nodes = list(graph.keys())
    for size1 in range(1, len(nodes) + 1):
        for subset1 in combinations(nodes, size1):
            V1 = set(subset1)
            candidates = [n for n in nodes if all(n in graph[v] for v in V1)]
            for size2 in range(1, len(candidates) + 1):
                for subset2 in combinations(candidates, size2):
                    V2 = set(subset2)
                    if all(graph[v1][v2][1] for v1 in V1 for v2 in V2):
                        bcliques.append((V1, V2))
    return bcliques

def find_maximal_bcliques(graph):
    """
    Identify maximal B-cliques in the graph.
    :param graph: Input graph (dictionary representation).
    :return: List of maximal B-cliques [(V1, V2)].
    """
    all_bcliques = find_bcliques(graph)  # Find all B-cliques
    maximal_bcliques = []

    for bc1 in all_bcliques:
        V1_1, V2_1 = bc1
        is_maximal = True

        for bc2 in all_bcliques:
            if bc1 == bc2:
                continue
            V1_2, V2_2 = bc2
            # Check if bc1 is a subset of bc2
            if V1_1.issubset(V1_2) and V2_1.issubset(V2_2):
                is_maximal = False
                break

        if is_maximal:
            maximal_bcliques.append(bc1)

    return maximal_bcliques

def compute_edge_lags(graph, bclique):
    V1, V2 = bclique
    edge_lags = {}
    for v1 in V1:
        for v2 in V2:
            # Use type 1 if available, else type 2.
            if 1 in graph[v1][v2]:
                edge_lags[(v1, v2)] = graph[v1][v2][1]
            elif 2 in graph[v1][v2]:
                edge_lags[(v1, v2)] = graph[v1][v2][2]
            else:
                raise KeyError(f"No directed or bidirected edge found for ({v1}, {v2}).")
    return edge_lags

def compute_directed_lags(g, v, w, unobserved):
    """
    Compute d_O[v, w] using CRD paths.
    """
    paths = find_crd_paths(g, v, w, unobserved)  # Implement pathfinding logic
    edge_lags = set()
    for path in paths:
        edge_lags.update(compute_path_length(path))  # Aggregate path lengths
    return edge_lags

def compute_bi_directed_lags(g, v, w, unobserved):
    """
    Compute b_O[v, w] using h-treks.
    """
    treks = find_h_treks(g, v, w, unobserved)  # Implement h-trek logic
    edge_lags = set()
    for trek in treks:
        edge_lags.update(compute_trek_lags(trek))  # Aggregate trek lags
    return edge_lags

class SolutionNotFoundInTime(Exception):
    pass


def ptloopnum(pt):
    """
    Given a PathTree object returns the number of loops in it
    :param pt: PathTree object
    :return: number of loops (n)
    """

    def ptn(pt, n=0):
        for e in pt.children:
            if type(e) is int:
                n += 1
                continue
            n += ptn(e, n=1)
        return n

    return ptn(pt)


def ptnodenum(pt):
    """
    Given a PathTree object returns the number of latents that comprise it
    :param pt: PathTree object
    :return: number of nodes (n)
    """
    n = pt.preset - 1

    def ptn(pt, n=0):
        for e in pt.children:
            if type(e) is int:
                n += e - 1
                continue
            n += ptn(e, n=1)
        return n

    return n + ptn(pt)


def ptelement(pt, w):
    """
    An element generated by a PathTree with a given weight setting
    :param pt: PathTree
    :param w: a list of weights
    :return: an integer
    """
    n = pt.preset

    def sumloops(pt, w):
        n = 0
        ls = list(pt.children)
        for i in range(len(ls)):
            if type(ls[i]) is int:
                n += w[i] * ls[i]
                continue
            n += w[i][0] * ls[i].preset \
                 + min(1, w[i][0]) * sumloops(ls[i], w[i][1])
        return n

    return n + sumloops(pt, w)


def weights_pt(pt, weights):
    c = [0]

    def crawl(pt, w, c):
        wl = []
        for e in pt.children:
            if type(e) is int:
                wl.append(w[c[0]])
                c[0] += 1
                continue
            ww = w[c[0]]
            c[0] += 1
            wl.append([ww, crawl(e, w, c)])
        return wl

    return crawl(pt, weights, c)


def extraloops_pt(pt, loops):  # loops are tuples (loop, weight)
    c = [0]

    def crawl(pt, l, c):
        first = [l[c[0]]]
        wl = []
        for e in pt.children:
            c[0] += 1
            if type(e) is int:
                wl.append(l[c[0]])
                continue
            wl.append(crawl(e, l, c))
        return first + [wl]

    return crawl(pt, loops, c)


def ptelement_extraloop(pt, w, eloops, solver):
    # Compute the base delay.
    n = pt.preset + eloops[0][0] * eloops[0][1]
    
    def sumloops(pt, w, lps, solver):
        ls = list(pt.children)  # using 'children' in place of loopset
        total_expr = 0
        for i in range(len(ls)):
            # Instead of using Python's min(1, w[i]), use solver.IfThenElse to get an indicator:
            # indicator = 1 if w[i] > 0, else 0.
            indicator = solver.IfThenElse(w[i] > 0, 1, 0)
            
            if isinstance(ls[i], int):
                total_expr += w[i] * ls[i] + indicator * lps[i][0] * lps[i][1]
            else:
                # For a nested child, assume w[i] is a list: w[i][0] for the current level,
                # and recursively use w[i][1] for deeper levels.
                total_expr += w[i][0] * ls[i].preset + indicator * (
                    lps[i][0][0] * lps[i][0][1] + sumloops(ls[i], w[i][1], lps[i][1], solver)
                )
        return total_expr
    
    return n + sumloops(pt, w, eloops[1], solver)
def isptelement_el(el, pt, w, eloops, solver):
    return el == ptelement_extraloop(pt, w, eloops, solver)


def isptsubset_el(elist, pt, w, eloops, solver):
    for i in range(elist[-1]):
        if isptelement_el(i, pt, w, eloops, solver):
            if not i in elist:
                return False
    return True


def isrightpt(el, elist, pt, w, eloops, solver):
    for i in range(elist[-1]):
        if isptelement_el(i, pt, w, eloops, solver):
            if not i in elist:
                return False
        if i == el and not isptelement_el(i, pt, w, eloops, solver):
            return False
    return True

def safe_int(x):
    """
    Attempt to convert x to an integer. If x is not a plain number (e.g. an InfiniteExpression),
    then raise an error.
    """
    if isinstance(x, (int, float)):
        return int(x)
    else:
        # We no longer attempt to convert symbolic types via int.
        raise TypeError(f"Cannot convert {x} (type {type(x)}) to int.")

def ptelements(pt, observed, seqlen=100, verbose=False, maxloop=100):
    """
    Generate the first `seqlen` delay values from a PathTree,
    but only those delays that are in the observed set.
    
    :param pt: A PathTree object.
    :param observed: A set (or list) of allowed delay values.
    :param seqlen: The number of delay values to generate.
    :param verbose: If True, prints solver statistics.
    :param maxloop: Upper bound for weight variables.
    :return: A list of delay values (only those that are in observed).
    """
    solver = pywrapcp.Solver("pt-elements")
    
    # If there are no children, the overall delay is just the preset.
    if not pt.children:
        # Only treat as "flat" if the preset is already a plain number.
        if isinstance(pt.preset, (int, float)):
            if pt.preset in observed:
                return [pt.preset]
            else:
                raise ValueError(f"Preset {pt.preset} is not in the observed set {observed}.")
        # Otherwise, fall through to constraint solving.
    
    # Otherwise, use the constraint solver.
    N = ptloopnum(pt)  # Number of loops in the PathTree
    weights = [solver.IntVar(0, maxloop, f"w[{i:04d}]") for i in range(N)]
    ws = weights_pt(pt, weights)
    delay_expr = ptelement(pt, ws)
    
    # Make sure the observed set contains plain numbers.
    numeric_observed = [int(x) for x in observed if isinstance(x, (int, float))]
    if not numeric_observed:
        raise ValueError("Observed set does not contain any numeric values.")
    
    # Add a constraint that the computed delay must be one of the observed values.
    solver.Add(solver.MemberCt(delay_expr, numeric_observed))
    
    solution = solver.Assignment()
    solution.Add(weights)
    db = solver.Phase(weights,
                      solver.CHOOSE_FIRST_UNBOUND,
                      solver.ASSIGN_MIN_VALUE)
    solver.NewSearch(db)
    
    num_solutions = 0
    els = set()
    while solver.NextSolution():
        w_values = [x.Value() for x in weights]
        # weights_pt can work with a plain list of numbers
        nested_ws = weights_pt(pt, w_values)
        delay_val = ptelement(pt, nested_ws)
        els.add(delay_val)
        num_solutions += 1
        if len(els) >= seqlen:
            break
    solver.EndSearch()
    
    if verbose:
        print("num_solutions:", num_solutions)
        print("failures:", solver.Failures())
        print("branches:", solver.Branches())
        print("WallTime:", solver.WallTime())
    
    return list(els)


def isptelement(pt, element, verbose=False, maxloop=100):
    """
    Check if an integer element is in the weight set represented by the PathTree.
    If the PathTree is flat (no children), and its preset is a set, check membership;
    otherwise, use the constraint solver to verify if 'element' is generated by the PathTree.
    
    :param pt: a PathTree object
    :param element: an integer candidate delay
    :param verbose: whether to print debugging information
    :param maxloop: upper bound for weight variables
    :return: True if 'element' is representable by pt, else False
    """
    solver = pywrapcp.Solver("isptelement")
    weights = []
    N = ptloopnum(pt)  # Number of loops (children) in the PathTree

    # If there are no children, then the delay is given directly by pt.preset.
    if not N:
        if isinstance(pt.preset, set):
            return element in pt.preset
        else:
            return element == pt.preset

    # Otherwise, initialize weight variables.
    for i in range(N):
        weights.append(solver.IntVar(0, maxloop, "w[%04i]" % i))

    # Get the weighted representation of the PathTree.
    wpt = weights_pt(pt, weights)
    solver.Add(element == ptelement(pt, wpt))

    solution = solver.Assignment()
    solution.Add(weights)
    db = solver.Phase(weights,
                      solver.CHOOSE_FIRST_UNBOUND,
                      solver.ASSIGN_MIN_VALUE)
    solver.NewSearch(db)

    solution_exists = False
    while solver.NextSolution():
        solution_exists = True
        break
    solver.EndSearch()

    if verbose:
        print("Failures:", solver.Failures())
        print("Branches:", solver.Branches())
        print("WallTime:", solver.WallTime())

    return solution_exists


def loops_and_weights(solver, loops, weights):
    """
    Add constraints to solver that make sure loops are not generated if subtree is not active due to a zero weight upstream
    :param solver:
    :param loops:
    :param weights:
    :return:
    """

    def recurse(s, l, w):
        for ww, ll in zip(w, l):
            if type(ww) is list:
                for e in flatten(ll):
                    s.Add((ww[0] == 0) <= (e == 0))
                recurse(s, ll[1:], ww[1:])
            else:
                for e in flatten(ll):
                    s.Add((ww == 0) <= (e == 0))

    recurse(solver, loops[1], weights)


def eloops_simplify(eloops):
    l = []
    for e in eloops:
        if type(e) is list:
            l.append(eloops_simplify(e))
        else:
            l.append(int(e[0].Value()))
    return l


def ptaugmented(pt, eloops):
    def augment(pt, ls):
        pre = pt.preset
        loop = pt.children
        s = set()
        if ls[0]:
            s.add(ls[0])
        for l, el in zip(loop, ls[1]):
            if type(l) is int:
                if not el:
                    s.add(l)
                else:
                    s.add(PathTree({el}, pre=l))
                continue
            s.add(augment(l, el))

        return PathTree(s, pre=pre)

    t = augment(pt, eloops)

    return t


def ptsubset(pt, elist):
    for i in range(elist[-1]):
        if isptelement(pt, i) and not i in elist:
            return False
    return True


def smallest_pt(ptlist):
    if ptlist:
        idx = np.argsort(map(ptnodenum, ptlist))
        sol = ptlist[idx[0]]
    else:
        sol = None
    return sol


def pairprint(pt1, pt2, k=40):
    print(np.c_[pt2seq(pt1, k), pt2seq(pt2, k)])


def etesteq(pt1, pt2, k=100):
    a1 = np.asarray(pt2seq(pt1, k))
    a2 = np.asarray(pt2seq(pt2, k))
    return np.sum(a1 - a2) == 0


def keeptreegrow(pt, e, seq, cutoff=10, cap=1000):
    t = None
    while t is None:
        t = growtree(pt, e, seq, cutoff=cutoff)
        cutoff += 10
        if cutoff > cap:
            raise SolutionNotFoundInTime("Cannot keep the tree growing")
    return t


def add_element(d, pt):
    """
    Add a PathTree to dictionary d such that it is either appended to the list or added anew
    Args:
        d: a dictionary
        pt: a PathTree

    Returns:

    """
    key = ptnodenum(pt)
    if key in d:
        d[key].append(pt)
    else:
        d[key] = pt


def del_element(d, pt, key=None):
    """
    Delete a PathTree from dictionary d such that it is either removed from the list or the list that only contains one element is removed
    Args:
        d: a dictionary
        pt: a PathTree

    Returns:

    """
    if key is None:
        key = ptnodenum(pt)
    if len(d[key]) == 1:
        del d[key]
    else:
        d[key].remove(pt)


def swap_elements(d, pt1, pt2, key=None):
    del_element(d, pt1, key=key)
    add_element(d, pt2)


def seq2pt(seq, verbose=False, cutoff=100):
    if not seq:
        return None

    pt = PathTree({}, pre=seq[0])
    pts = SortedDict()  # PathTrees
    pts[ptnodenum(pt)] = [pt]

    for e in seq[1:]:
        e_is_in = False
        for key in pts:
            for pt in pts[key]:
                if verbose:
                    print(e)
                try:
                    newpt = keeptreegrow(pt, e, seq, cutoff=cutoff)
                    swap_elements(pts, pt, newpt, key=key)
                    e_is_in = True
                    break
                except SolutionNotFoundInTime:
                    continue
        if not e_is_in:
            newpt = PathTree({}, pre=e)
            add_element(d, newpt)

    return pt

def update_edge_lags(graph, bclique, new_pt):
    V1, V2 = bclique

    # Obtain the overall delay expression as a sympy expression.
    expr = sympify(new_pt.get_overall_delay_expr())
    # Extract the constant part from the expression.
    const_part = expr.as_coeff_Add()[0]
    # Compute the remainder (the cycle contribution) as the difference.
    remainder = expr - const_part

    # Create a new PathTree for the edge with root preset equal to the constant part.
    pt_edge = PathTree(preset=const_part)
    # If there is a nonzero remainder, represent it as a child.
    if remainder != S.Zero:
        # For simplicity, assume the remainder is of the form coefficient*symbol.
        coeff, term = remainder.as_coeff_Mul()
        pt_child = PathTree(preset=coeff)
        pt_edge.add_child(pt_child)

    for v1 in V1:
        for v2 in V2:
            graph[v1][v2][1] = pt_edge
    return graph



def growtree(pt, element, ref_elements, verbose=False, maxloop=100, cutoff=100):
    """
    Extend a PathTree by adding a loop (child node) so that it can generate a given candidate delay value,
    but only if that candidate delay is in the observed edge-lag set (ref_elements).

    If the current PathTree is flat (i.e. no loops) and element > pt.preset, add a child with preset = element - pt.preset.
    
    :param pt: A PathTree object.
    :param element: An integer candidate delay that we want the PathTree to generate.
    :param ref_elements: A list (or set) of observed edge-lag values.
    :param verbose: If True, print debugging output.
    :param maxloop: Maximum value for weight variables.
    :param cutoff: Maximum number of solutions to try.
    :return: A refined PathTree that can generate the candidate delay, or None if extension isnâ€™t possible.
    """
    
    solver = pywrapcp.Solver("loop_an_element")

    # If the current PathTree already generates the element, return it.
    if isptelement(pt, element):
        return pt

    N = ptloopnum(pt)  # Number of loops (children) in the PathTree

    # If there are no loops, the only possible delay is the preset.
    if N == 0:
        if element != pt.preset:
            # If the candidate is greater than the preset, try to extend the tree by adding a child.
            if element > pt.preset:
                # Create a new child with preset = element - pt.preset.
                new_child = PathTree(preset=(element - pt.preset))
                new_child.label = 0  # Set a default label.
                pt.add_child(new_child)
                # Check whether the updated tree now generates the candidate.
                if isptelement(pt, element):
                    return pt
                else:
                    return None
            else:
                return None
        else:
            return pt

    # For N > 0, initialize weight variables.
    weights = []
    for i in range(N):
        weights.append(solver.IntVar(0, maxloop, f"w[{i:04d}]"))

    # Initialize extra loop variables.
    loops = []
    lweights = []
    ltuples = []
    for i in range(N + 1):
        lw = solver.IntVar(0, maxloop, f"lw[{i:04d}]")
        l = solver.IntVar(0, maxloop, f"l[{i:04d}]")
        lweights.append(lw)
        loops.append(l)
        ltuples.append((l, lw))

    # Compute extra loop contributions and weight expression.
    eloops = extraloops_pt(pt, ltuples)
    ws = weights_pt(pt, weights)

    # Filter ref_elements to numeric values.
    numeric_ref_elements = [int(x) for x in ref_elements if isinstance(x, int)]
    if not numeric_ref_elements:
        raise ValueError("No numeric edge-lag values found in ref_elements.")

    # Add constraints ensuring the overall delay equals the candidate and belongs to the observed set.
    solver.Add(solver.MemberCt(ptelement_extraloop(pt, ws, eloops, solver), numeric_ref_elements))
    solver.Add(element == ptelement_extraloop(pt, ws, eloops, solver))

    # Additional constraints (e.g. at most one loop is "active").
    solver.Add(solver.Count(loops, 0, len(loops) - 1))
    solver.Add(solver.Count(lweights, 0, len(lweights) - 1))
    for i in range(len(lweights)):
        solver.Add((lweights[i] == 0) <= (loops[i] == 0))
    loops_and_weights(solver, eloops, ws)

    # Run the solver.
    solution = solver.Assignment()
    solution.Add(loops)
    db = solver.Phase(loops + lweights + weights,
                      solver.CHOOSE_FIRST_UNBOUND,
                      solver.ASSIGN_MIN_VALUE)
    solver.NewSearch(db)

    numsol = 0
    pts_found = []
    while solver.NextSolution():
        new_pt = ptaugmented(pt, eloops_simplify(eloops))
        if verbose:
            print("Trying PathTree:", new_pt)
        if ptsubset(new_pt, ref_elements):
            pts_found.append(new_pt)
            if verbose:
                print("Accepted PathTree:", new_pt)
        numsol += 1
        if numsol >= cutoff:
            break
    solver.EndSearch()

    if verbose:
        print("Solutions found:", numsol)
        print("Failures:", solver.Failures())
        print("Branches:", solver.Branches())
        print("WallTime:", solver.WallTime())
        print("For element", element, "solutions found:", numsol)

    if pts_found:
        return smallest_pt(pts_found)
    else:
        return None


def refine_path_tree(graph, bcliques):
    """
    Iteratively refine PathTrees across the graph for all B-cliques.
    :param graph: Input graph (dictionary representation).
    :param bcliques: List of B-cliques.
    :return: Updated PathTrees for the graph.
    """
    for bclique in bcliques:
        V1, V2 = bclique
        edge_lags = compute_edge_lags(graph, bclique)
        
        # For each edge in the B-clique, refine the PathTree
        for (v1, v2), lag_set in edge_lags.items():
            pt = PathTree(lag_set)  # Initialize a PathTree for the edge
            refined_pt = keeptreegrow(pt, v2, list(lag_set))  # Refine PathTree
            graph[v1][v2][1] = refined_pt.children  # Update the graph
    return graph

def apply_minimal_refinement(graph, bcliques):
    """
    Apply minimal PathTree refinements across the graph.
    :param graph: Input graph.
    :param bcliques: List of B-cliques.
    :return: Refined graph.
    """
    for bclique in bcliques:
        edge_lags = compute_edge_lags(graph, bclique)
        for (v1, v2), lag_set in edge_lags.items():
            pt = PathTree(lag_set)
            refined_pts = [growtree(pt, lag, list(lag_set)) for lag in lag_set]
            minimal_pt = smallest_pt(refined_pts)
            update_edge_lags(graph, bclique, minimal_pt)
    return graph

def refine_edges(graph, bcliques, unobserved):
    for bclique in bcliques:
        for v in bclique[0]:  # V1
            for w in bclique[1]:  # V2
                if v != w:
                    graph[v][w][1] = compute_directed_lags(graph, v, w, unobserved)
                    graph[w][v][1] = compute_bi_directed_lags(graph, v, w, unobserved)
    return graph

def pt2seq(pt, num):
    if not pt.children:
        return [pt.preset]
    i = 0
    s = set()
    while len(s) < num:
        if isptelement(pt, i, maxloop=10 * num):
            s.add(i)
        i += 1
    l = list(s)
    l.sort()
    return l


def s2spt(s):  # convert edge set to pt
    ss = set()
    for e in s:
        if type(e) is int:
            ss.add(PathTree({0}, pre={e}))
            continue
        ss.add(e)
    return ss


def spt_elements(spt, num):
    """
    Generate numbers from a set of PathTrees
    :param spt: set of PathTrees
    :param num: number of elements (from the first) to generate
    :return: list of num numbers
    """
    i = 0
    s = set()
    while len(s) < num:
        if issptelement(spt, i):
            s.add(i)
        i += 1
    return list(s)


def issptelement(spt, element):
    a = False
    for pt in s2spt(spt):
        a = a or isptelement(pt, element)
    return a

def unify_edge_representation(graph):
    """
    Convert all edges in the graph so that they store a PathTree, even if
    originally they were just a set of integers.
    """
    for u in graph:
        for v in graph[u]:
            edge_data = graph[u][v]
            if 1 in edge_data:  # directed
                if isinstance(edge_data[1], set):
                    # Wrap the set in a PathTree
                    edge_data[1] = PathTree(preset=edge_data[1], loopset=set())
            elif 2 in edge_data:  # bidirected
                if isinstance(edge_data[2], set):
                    edge_data[2] = PathTree(preset=edge_data[2], loopset=set())
    return graph

def print_graph_as_pathtrees(graph):
    """
    Print the edges in the graph. If an edge-lag is a PathTree, display it directly.
    """
    for u in sorted(graph.keys()):
        for v in sorted(graph[u].keys()):
            edge_data = graph[u][v]
            if 1 in edge_data:  # directed
                print(f"  {u} -> {v} = {edge_data[1]}")
            elif 2 in edge_data:  # bidirected
                print(f"  {u} <-> {v} = {edge_data[2]}")